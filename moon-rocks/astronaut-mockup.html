<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moon Rocks - Astronaut Animation Mockup</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            touch-action: none;
            background: #000;
        }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #888;
            font-size: 11px;
            font-family: monospace;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">MOON ROCKS - Touch higher = bigger hops, lower = quick hops</div>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Monochrome palette
        const colors = {
            sky: '#000000',
            surfaceLight: '#C8C8C8',
            surfaceMid: '#A0A0A0',
            surfaceDark: '#707070',
            surfaceDeep: '#404040',
            mountainFar: '#606060',
            mountainMid: '#505050',
            mountainNear: '#454545',
            suitBright: '#FFFFFF',
            suitLight: '#E8E8E8',
            suitMid: '#C0C0C0',
            suitDark: '#888888',
            suitShadow: '#505050',
            helmetWhite: '#FFFFFF',
            helmetGrey: '#D0D0D0',
            visorDark: '#151515',
            visorReflect: '#303030',
            plssLight: '#D0D0D0',
            plssDark: '#606060'
        };

        const state = {
            astronaut: {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                facingRight: true,
                flipProgress: 1,

                // Walk state
                isWalking: false,
                moveDirection: 0,    // -1 left, 0 stopped, +1 right (with hysteresis)
                stepFoot: 0,         // 0 = left foot forward, 1 = right foot forward

                // Hop state
                airborne: false,
                hopProgress: 0,      // 0 = just pushed off, 1 = about to land

                // Variation for organic feel
                hopVariation: 1.0,   // Random 0.6-1.4 each hop
                hopSpeedVar: 1.0,    // Random timing variation
                armWobble: 0,        // Slight arm adjustment
                bodySquash: 1.0,     // Squash on land, stretch in air
                landingVelocity: 0,  // For dust amount

                // Limb angles (in radians)
                leftHipAngle: 0,
                leftKneeAngle: 0,
                rightHipAngle: 0,
                rightKneeAngle: 0,
                leftShoulderAngle: 0,
                leftElbowAngle: 0,
                rightShoulderAngle: 0,
                rightElbowAngle: 0,

                bodyTilt: 0,
                bodyBob: 0           // Vertical compression
            },
            lander: { x: 0, y: 0 },
            finger: { x: null, y: null, screenX: null, active: false },
            camera: { x: 0 },
            stars: [],
            footprints: [],
            dustParticles: [],
            groundY: 0
        };

        function initStars() {
            state.stars = [];
            for (let i = 0; i < 100; i++) {
                state.stars.push({
                    x: Math.random() * 4000 - 2000,
                    y: Math.random() * canvas.height * 0.4,
                    size: Math.random() * 1.2 + 0.3,
                    brightness: Math.random() * 0.6 + 0.4
                });
            }
        }

        function init() {
            state.groundY = canvas.height * 0.72;
            state.lander.x = canvas.width / 2;
            state.lander.y = state.groundY;
            state.astronaut.x = state.lander.x - 120;
            state.astronaut.y = state.groundY;
            state.camera.x = state.astronaut.x - canvas.width / 2;
            initStars();
        }

        // Input - track SCREEN position, compute world position each frame
        function handleStart(x, y) {
            state.finger.active = true;
            state.finger.screenX = x;  // Store screen position
            state.finger.y = y;
        }
        function handleMove(x, y) {
            if (state.finger.active) {
                state.finger.screenX = x;  // Store screen position
                state.finger.y = y;
            }
        }
        function handleEnd() {
            state.finger.active = false;
        }

        // Call this each frame to update world position from screen position
        function updateFingerWorldPosition() {
            if (state.finger.active && state.finger.screenX !== null) {
                state.finger.x = state.finger.screenX + state.camera.x;
            }
        }

        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); });
        canvas.addEventListener('touchend', handleEnd);

        function addDust(x, y, vx, intensity = 1) {
            // More dust for harder landings
            const count = Math.floor(3 + intensity * 6);
            for (let i = 0; i < count; i++) {
                const spread = 10 + intensity * 15;
                const speed = 0.8 + intensity * 1.5;
                state.dustParticles.push({
                    x: x + (Math.random() - 0.5) * spread,
                    y: y - Math.random() * 3,
                    vx: vx * 0.15 + (Math.random() - 0.5) * speed * 2,
                    vy: -Math.random() * speed - 0.3,
                    life: 0.7 + intensity * 0.5,
                    size: Math.random() * (2 + intensity * 2) + 1.5
                });
            }
        }

        function updateDust(dt) {
            for (let i = state.dustParticles.length - 1; i >= 0; i--) {
                const d = state.dustParticles[i];
                d.x += d.vx;
                d.y += d.vy;
                d.vy += 0.015;
                d.life -= dt * 0.7;
                if (d.life <= 0) state.dustParticles.splice(i, 1);
            }
        }

        function addFootprint(x, y) {
            if (state.footprints.length > 80) state.footprints.shift();
            state.footprints.push({ x, y });
        }

        function updateAstronaut(dt) {
            const astro = state.astronaut;
            const finger = state.finger;
            const groundY = state.groundY;

            // Simple, direct puppet control
            let wantToWalk = false;
            let walkDirection = 0;
            let hopIntensity = 1.0;

            if (finger.active && finger.x !== null) {
                const dx = finger.x - astro.x;

                // Finger height controls hop intensity
                const fingerYNorm = finger.y / canvas.height;
                hopIntensity = 4.5 - fingerYNorm * 4.25;
                hopIntensity = Math.max(0.25, Math.min(5.0, hopIntensity));

                const moveThreshold = 15;

                if (Math.abs(dx) > moveThreshold) {
                    wantToWalk = true;
                    const fingerDirection = dx > 0 ? 1 : -1;

                    // ONLY change direction when ON THE GROUND
                    // This makes movement feel committed and responsive
                    if (!astro.airborne) {
                        walkDirection = fingerDirection;

                        // Update facing to match
                        const shouldFaceRight = walkDirection > 0;
                        if (shouldFaceRight !== astro.facingRight) {
                            astro.facingRight = shouldFaceRight;
                            astro.flipProgress = 0;
                        }
                    } else {
                        // In air - keep the direction we launched with
                        walkDirection = astro.facingRight ? 1 : -1;
                    }
                }
            }

            // Moon physics
            const moonGravity = 0.2;
            const baseHopStrength = 3.5;
            const baseWalkSpeed = 4.5;

            if (wantToWalk) {
                astro.isWalking = true;
                const targetVx = walkDirection * baseWalkSpeed * (0.5 + hopIntensity * 0.4);
                astro.vx += (targetVx - astro.vx) * 0.2;

                // Start hop if on ground
                if (!astro.airborne) {
                    astro.hopVariation = hopIntensity * (0.9 + Math.random() * 0.2);
                    astro.vy = -baseHopStrength * astro.hopVariation;
                    astro.airborne = true;
                    astro.stepFoot = 1 - astro.stepFoot;
                    astro.hopProgress = 0;
                    addDust(astro.x, groundY, astro.vx, astro.hopVariation * 0.5);
                    addFootprint(astro.x, groundY);
                }
            } else {
                // Not actively walking toward finger
                if (astro.airborne) {
                    // In air - keep momentum, just reduce slightly
                    astro.vx *= 0.98;
                } else {
                    // On ground - slow down faster
                    astro.isWalking = false;
                    astro.vx *= 0.85;
                    if (Math.abs(astro.vx) < 0.1) astro.vx = 0;
                }
            }

            // Gravity and hop progress
            if (astro.airborne) {
                astro.vy += moonGravity;
                // Progress synced to actual hop physics
                // Hop duration in frames = 2 * initialVy / gravity = 2 * (3.5 * hopVariation) / 0.2 = 35 * hopVariation
                const hopDurationFrames = 35 * astro.hopVariation;
                const progressRate = 1.0 / Math.max(10, hopDurationFrames);  // At least 10 frames
                astro.hopProgress = Math.min(1, astro.hopProgress + progressRate);

                // Stretch at peak of hop
                if (astro.vy < 0.5 && astro.vy > -0.5) {
                    astro.bodySquash = 1.04;  // Slight stretch at apex
                } else {
                    astro.bodySquash += (1.0 - astro.bodySquash) * 0.1;
                }

                // Track velocity for landing dust
                astro.landingVelocity = astro.vy;
            }

            // Apply velocities
            astro.x += astro.vx;
            astro.y += astro.vy;

            // Ground collision
            if (astro.y >= groundY) {
                astro.y = groundY;
                if (astro.airborne) {
                    // Landing! More dust for harder landings
                    const landIntensity = Math.min(1.5, Math.abs(astro.landingVelocity) / 3);
                    addDust(astro.x, groundY, astro.vx, landIntensity);

                    // Squash on landing
                    astro.bodySquash = 0.88 - landIntensity * 0.05;
                    astro.bodyBob = landIntensity * 8;  // Compress down

                    astro.airborne = false;
                    astro.vy = 0;
                    astro.hopProgress = 0;
                }
            }

            // Body bob recovery (spring back from landing compression)
            astro.bodyBob *= 0.75;
            astro.bodySquash += (1.0 - astro.bodySquash) * 0.15;

            // Update flip animation
            if (astro.flipProgress < 1) {
                astro.flipProgress += dt * 5;
                if (astro.flipProgress > 1) astro.flipProgress = 1;
            }

            // Calculate limb angles based on walk phase and airborne state
            updateLimbAngles(astro, dt);

        }

        function updateLimbAngles(astro, dt) {
            const foot = astro.stepFoot; // 0 or 1, alternates each hop
            const hv = Math.min(astro.hopVariation || 1.0, 3.0);  // Cap for sanity

            if (astro.airborne) {
                // Smooth sine curve through the hop
                const hp = astro.hopProgress;
                const spread = Math.sin(hp * Math.PI);

                // Small leg separation - alternates each hop
                // Keeps legs mostly under body but not tied together
                const legSign = foot === 0 ? 1 : -1;
                const legSpread = spread * 0.12;  // Small amount
                astro.leftHipAngle = -legSpread * legSign;
                astro.rightHipAngle = legSpread * legSign;

                // Bounce from knee bending
                const kneeBend = 0.6 + spread * 0.6;  // 35-70 degrees
                astro.leftKneeAngle = kneeBend;
                astro.rightKneeAngle = kneeBend;

                // Arms swing opposite to each other (like natural walking)
                // Also float up slightly in low gravity
                const armSwing = spread * 0.4;
                const armLift = spread * 0.2;

                // Opposite arm to leg - if left leg forward, right arm forward
                if (foot === 0) {
                    // Left leg forward, so RIGHT arm forward, LEFT arm back
                    astro.leftShoulderAngle = 0.1 + armSwing - armLift;   // Back
                    astro.rightShoulderAngle = -0.3 - armSwing - armLift; // Forward
                } else {
                    // Right leg forward, so LEFT arm forward, RIGHT arm back
                    astro.leftShoulderAngle = -0.3 - armSwing - armLift;  // Forward
                    astro.rightShoulderAngle = 0.1 + armSwing - armLift;  // Back
                }

                astro.leftElbowAngle = -0.7;
                astro.rightElbowAngle = -0.7;

            } else if (astro.isWalking) {
                // On ground - crouch
                astro.leftHipAngle = 0;
                astro.rightHipAngle = 0;
                astro.leftKneeAngle = 0.6;
                astro.rightKneeAngle = 0.6;

                // Arms slightly forward, relaxed
                astro.leftShoulderAngle = -0.15;
                astro.rightShoulderAngle = -0.15;
                astro.leftElbowAngle = -0.7;
                astro.rightElbowAngle = -0.7;

            } else {
                // Idle - relaxed stance with gentle breathing motion
                const decay = 0.88;
                const breathe = Math.sin(Date.now() * 0.0015) * 0.025;
                const sway = Math.sin(Date.now() * 0.001) * 0.015;

                astro.leftHipAngle *= decay;
                astro.rightHipAngle *= decay;
                astro.leftKneeAngle = astro.leftKneeAngle * decay + 0.12 * (1 - decay);
                astro.rightKneeAngle = astro.rightKneeAngle * decay + 0.12 * (1 - decay);

                astro.leftShoulderAngle = astro.leftShoulderAngle * decay + (0.38 + sway) * (1 - decay);
                astro.rightShoulderAngle = astro.rightShoulderAngle * decay + (0.38 - sway) * (1 - decay);
                astro.leftElbowAngle = astro.leftElbowAngle * decay + (-0.9 + breathe) * (1 - decay);
                astro.rightElbowAngle = astro.rightElbowAngle * decay + (-0.9 - breathe) * (1 - decay);
            }
        }

        function updateCamera() {
            const targetX = state.astronaut.x - canvas.width / 2;
            state.camera.x += (targetX - state.camera.x) * 0.05;
        }

        // === DRAWING ===

        function drawStars() {
            state.stars.forEach(star => {
                const screenX = star.x - state.camera.x * 0.05;
                if (screenX < -5 || screenX > canvas.width + 5) return;
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.beginPath();
                ctx.arc(screenX, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawMountains() {
            const groundY = state.groundY;

            ctx.fillStyle = colors.mountainFar;
            ctx.beginPath();
            ctx.moveTo(0, groundY - 30);
            for (let x = 0; x <= canvas.width; x += 50) {
                const worldX = x + state.camera.x * 0.1;
                const h = Math.sin(worldX * 0.003) * 40 + Math.sin(worldX * 0.007) * 25 + 50;
                ctx.lineTo(x, groundY - h);
            }
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = colors.mountainMid;
            ctx.beginPath();
            ctx.moveTo(0, groundY - 20);
            for (let x = 0; x <= canvas.width; x += 40) {
                const worldX = x + state.camera.x * 0.2;
                const h = Math.sin(worldX * 0.005 + 1) * 30 + Math.sin(worldX * 0.01) * 20 + 35;
                ctx.lineTo(x, groundY - h);
            }
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = colors.mountainNear;
            ctx.beginPath();
            ctx.moveTo(0, groundY - 10);
            for (let x = 0; x <= canvas.width; x += 30) {
                const worldX = x + state.camera.x * 0.35;
                const h = Math.sin(worldX * 0.008 + 2) * 20 + Math.sin(worldX * 0.015) * 12 + 18;
                ctx.lineTo(x, groundY - h);
            }
            ctx.lineTo(canvas.width, groundY);
            ctx.lineTo(0, groundY);
            ctx.closePath();
            ctx.fill();
        }

        function drawSurface() {
            const groundY = state.groundY;
            const grad = ctx.createLinearGradient(0, groundY, 0, canvas.height);
            grad.addColorStop(0, colors.surfaceLight);
            grad.addColorStop(0.2, colors.surfaceMid);
            grad.addColorStop(0.6, colors.surfaceDark);
            grad.addColorStop(1, colors.surfaceDeep);
            ctx.fillStyle = grad;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            ctx.fillStyle = colors.surfaceDark;
            for (let i = 0; i < 40; i++) {
                const wx = (i * 97 + state.camera.x * 0.5) % (canvas.width + 100) - 50;
                const wy = groundY + 8 + (i % 5) * 20;
                ctx.beginPath();
                ctx.arc(wx, wy, 1.5 + (i % 4), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFootprints() {
            ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
            state.footprints.forEach(fp => {
                const sx = fp.x - state.camera.x;
                if (sx < -15 || sx > canvas.width + 15) return;
                ctx.beginPath();
                ctx.ellipse(sx, fp.y + 3, 6, 10, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawDust() {
            state.dustParticles.forEach(d => {
                const sx = d.x - state.camera.x;
                ctx.fillStyle = `rgba(180, 180, 180, ${d.life * 0.6})`;
                ctx.beginPath();
                ctx.arc(sx, d.y, d.size * d.life, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawLunarLander() {
            const lander = state.lander;
            const sx = lander.x - state.camera.x;
            const sy = lander.y;

            ctx.save();
            ctx.translate(sx, sy);
            ctx.scale(1.1, 1.1);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(20, 5, 70, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = '#707070';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(-45, -70);
            ctx.lineTo(-85, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(45, -70);
            ctx.lineTo(85, 0);
            ctx.stroke();

            // Foot pads
            ctx.fillStyle = '#505050';
            ctx.beginPath();
            ctx.ellipse(-85, 0, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(85, 0, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Descent stage
            ctx.fillStyle = '#8B7355';
            ctx.beginPath();
            ctx.moveTo(-55, -70);
            ctx.lineTo(-65, -115);
            ctx.lineTo(65, -115);
            ctx.lineTo(55, -70);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#6B5344';
            ctx.lineWidth = 1;
            for (let i = 0; i < 7; i++) {
                ctx.beginPath();
                ctx.moveTo(-50 + i * 15, -110);
                ctx.lineTo(-45 + i * 15, -75);
                ctx.stroke();
            }

            // Ascent stage
            ctx.fillStyle = '#E0E0E0';
            ctx.beginPath();
            ctx.moveTo(-48, -115);
            ctx.lineTo(-52, -175);
            ctx.lineTo(-38, -200);
            ctx.lineTo(38, -200);
            ctx.lineTo(52, -175);
            ctx.lineTo(48, -115);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#A0A0A0';
            ctx.beginPath();
            ctx.moveTo(5, -115);
            ctx.lineTo(48, -115);
            ctx.lineTo(52, -175);
            ctx.lineTo(38, -200);
            ctx.lineTo(5, -200);
            ctx.closePath();
            ctx.fill();

            // Window
            ctx.fillStyle = '#202020';
            ctx.beginPath();
            ctx.moveTo(-22, -165);
            ctx.lineTo(-28, -140);
            ctx.lineTo(-5, -135);
            ctx.lineTo(-5, -170);
            ctx.closePath();
            ctx.fill();

            // Antenna
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -200);
            ctx.lineTo(0, -235);
            ctx.stroke();
            ctx.fillStyle = '#C0C0C0';
            ctx.beginPath();
            ctx.ellipse(0, -235, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ladder
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-62, -70);
            ctx.lineTo(-70, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-55, -70);
            ctx.lineTo(-63, 0);
            ctx.stroke();

            ctx.restore();

            // Flag
            drawFlag(sx - 130, sy);
        }

        function drawFlag(x, y) {
            ctx.save();
            ctx.translate(x, y);

            ctx.strokeStyle = '#A0A0A0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -70);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -70);
            ctx.lineTo(35, -70);
            ctx.stroke();

            ctx.fillStyle = '#BF0A30';
            ctx.fillRect(0, -70, 35, 22);
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 6; i++) {
                if (i % 2 === 1) ctx.fillRect(0, -70 + i * 3.5, 35, 3.5);
            }
            ctx.fillStyle = '#002868';
            ctx.fillRect(0, -70, 14, 12);

            ctx.restore();
        }

        function drawAstronaut() {
            const astro = state.astronaut;
            const sx = astro.x - state.camera.x;
            const sy = astro.y + astro.bodyBob;  // Add compression bob

            ctx.save();
            ctx.translate(sx, sy);

            // Shadow - smaller when higher, bigger when landing hard
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            const height = state.groundY - astro.y;
            const shadowScale = Math.max(0.6, 1 - height * 0.008);
            const shadowStretch = astro.airborne ? 1.2 + height * 0.003 : 1;
            ctx.beginPath();
            ctx.ellipse(15 * shadowScale, 5, 22 * shadowStretch * shadowScale, 7 * shadowScale, 0, 0, Math.PI * 2);
            ctx.fill();

            // 2.5D flip - astronaut faces direction of movement
            const ep = astro.flipProgress < 0.5
                ? 2 * astro.flipProgress * astro.flipProgress
                : 1 - Math.pow(-2 * astro.flipProgress + 2, 2) / 2;
            const scaleX = astro.facingRight ? -1 + ep * 2 : 1 - ep * 2;

            // Apply squash/stretch
            const squash = astro.bodySquash || 1.0;

            // Very subtle body tilt - just a hint of lean
            const tiltAmount = Math.min(0.08, Math.abs(astro.vx) * 0.012);  // Max ~4.5 degrees
            const visualTilt = astro.vx > 0 ? tiltAmount : -tiltAmount;
            ctx.rotate(visualTilt);

            ctx.scale(scaleX * (2 - squash), squash);  // Inverse width when squashing

            // Draw layered (back to front)
            // Back leg
            drawLeg(ctx, astro.rightHipAngle, astro.rightKneeAngle, true);
            // Back arm
            drawArm(ctx, astro.rightShoulderAngle, astro.rightElbowAngle, true);
            // PLSS backpack
            drawPLSS(ctx);
            // Torso
            drawTorso(ctx);
            // Front leg
            drawLeg(ctx, astro.leftHipAngle, astro.leftKneeAngle, false);
            // Front arm
            drawArm(ctx, astro.leftShoulderAngle, astro.leftElbowAngle, false);
            // Helmet
            drawHelmet(ctx);

            ctx.restore();
        }

        function drawPLSS(ctx) {
            ctx.save();
            ctx.translate(-8, -72);

            ctx.fillStyle = colors.plssLight;
            roundRect(ctx, -20, -38, 40, 55, 4);
            ctx.fill();

            ctx.fillStyle = colors.plssDark;
            ctx.beginPath();
            ctx.moveTo(10, -36);
            ctx.lineTo(18, -36);
            ctx.quadraticCurveTo(20, -36, 20, -34);
            ctx.lineTo(20, 15);
            ctx.quadraticCurveTo(20, 17, 18, 17);
            ctx.lineTo(10, 17);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = colors.suitDark;
            ctx.fillRect(-18, -22, 36, 3);
            ctx.fillRect(-18, -5, 36, 3);
            ctx.fillRect(-18, 8, 36, 3);

            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-20, -12);
            ctx.quadraticCurveTo(-32, -12, -32, 3);
            ctx.stroke();

            ctx.restore();
        }

        function drawTorso(ctx) {
            ctx.save();
            ctx.translate(0, -52);

            ctx.fillStyle = colors.suitLight;
            ctx.beginPath();
            ctx.ellipse(0, 0, 24, 32, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = colors.suitMid;
            ctx.beginPath();
            ctx.ellipse(7, 0, 17, 30, 0, -0.5, 1.2);
            ctx.fill();

            ctx.fillStyle = colors.suitDark;
            ctx.fillRect(-10, -13, 18, 22);

            ctx.fillStyle = '#404040';
            ctx.fillRect(-8, -10, 5, 5);
            ctx.fillRect(0, -10, 5, 5);
            ctx.fillRect(-8, -2, 5, 5);
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, -2, 5, 5);

            ctx.fillStyle = colors.suitDark;
            ctx.beginPath();
            ctx.ellipse(0, 28, 22, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawHelmet(ctx) {
            ctx.save();
            ctx.translate(0, -95);

            // Helmet shell
            ctx.fillStyle = colors.helmetWhite;
            ctx.beginPath();
            ctx.arc(0, 0, 26, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = colors.helmetGrey;
            ctx.beginPath();
            ctx.arc(5, 2, 23, -0.3, 1.7);
            ctx.fill();

            // Visor - facing FORWARD (side view), not at player
            // The visor wraps around the front-facing side of the helmet
            const visorGrad = ctx.createLinearGradient(5, -12, 20, 8);
            visorGrad.addColorStop(0, colors.visorReflect);
            visorGrad.addColorStop(0.4, colors.visorDark);
            visorGrad.addColorStop(1, '#080808');

            ctx.fillStyle = visorGrad;
            ctx.beginPath();
            // Visor is on the FRONT of helmet (positive X after flip)
            ctx.ellipse(6, 2, 16, 18, 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Subtle reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.ellipse(0, -4, 5, 4, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Neck ring
            ctx.fillStyle = colors.suitDark;
            ctx.beginPath();
            ctx.ellipse(0, 20, 20, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Side antenna nubs (communication)
            ctx.fillStyle = '#505050';
            ctx.beginPath();
            ctx.arc(-22, 0, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawArm(ctx, shoulderAngle, elbowAngle, isBack) {
            ctx.save();

            const shoulderX = isBack ? 16 : -20;
            const shoulderY = -68;
            ctx.translate(shoulderX, shoulderY);
            ctx.rotate(shoulderAngle);

            const baseColor = isBack ? colors.suitMid : colors.suitLight;
            const jointColor = colors.suitDark;
            const darkColor = isBack ? colors.suitDark : colors.suitMid;

            // Upper arm - puffy
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.ellipse(0, 16, 11, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Elbow ring
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.ellipse(0, 32, 9, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lower arm (rotates from elbow)
            ctx.save();
            ctx.translate(0, 32);
            ctx.rotate(elbowAngle);

            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.ellipse(0, 16, 10, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wrist ring
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.ellipse(0, 30, 8, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Glove
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.ellipse(0, 40, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
            ctx.restore();
        }

        function drawLeg(ctx, hipAngle, kneeAngle, isBack) {
            ctx.save();

            const hipX = isBack ? 8 : -8;
            const hipY = -24;
            ctx.translate(hipX, hipY);
            ctx.rotate(hipAngle);

            const baseColor = isBack ? colors.suitMid : colors.suitLight;
            const jointColor = colors.suitDark;
            const darkColor = isBack ? colors.suitDark : colors.suitMid;

            // Upper leg - puffy
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.ellipse(0, 20, 13, 24, 0, 0, Math.PI * 2);
            ctx.fill();

            // Knee ring
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.ellipse(0, 42, 11, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lower leg (rotates from knee)
            ctx.save();
            ctx.translate(0, 42);
            ctx.rotate(kneeAngle);

            ctx.fillStyle = baseColor;
            ctx.beginPath();
            ctx.ellipse(0, 20, 12, 22, 0, 0, Math.PI * 2);
            ctx.fill();

            // Boot top ring
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.ellipse(0, 40, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Moon boot - proper boot shape, not a cup
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            // Boot starts at ankle
            ctx.moveTo(-12, 40);
            // Back of boot goes down
            ctx.lineTo(-10, 55);
            // Heel
            ctx.lineTo(-12, 62);
            ctx.lineTo(-12, 68);
            // Sole - flat bottom
            ctx.lineTo(16, 68);
            // Toe curves up slightly
            ctx.lineTo(18, 65);
            ctx.lineTo(16, 55);
            // Front of boot
            ctx.lineTo(12, 40);
            ctx.closePath();
            ctx.fill();

            // Boot sole - darker
            ctx.fillStyle = colors.suitShadow;
            ctx.beginPath();
            ctx.moveTo(-12, 65);
            ctx.lineTo(-12, 70);
            ctx.lineTo(16, 70);
            ctx.lineTo(18, 65);
            ctx.lineTo(16, 65);
            ctx.lineTo(-10, 65);
            ctx.closePath();
            ctx.fill();

            // Tread marks on sole
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(-10, 66, 4, 3);
            ctx.fillRect(-3, 66, 4, 3);
            ctx.fillRect(4, 66, 4, 3);
            ctx.fillRect(11, 66, 4, 3);

            ctx.restore();
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // Game loop
        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updateFingerWorldPosition();  // Update finger world coords with current camera
            updateAstronaut(dt);
            updateCamera();
            updateDust(dt);

            ctx.fillStyle = colors.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawStars();
            drawMountains();
            drawSurface();
            drawFootprints();
            drawDust();
            drawLunarLander();
            drawAstronaut();

            requestAnimationFrame(gameLoop);
        }

        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
